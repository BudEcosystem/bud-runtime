---
title: 'Webhook Configuration'
description: 'Configure and manage webhooks for async events in Bud Runtime'
---

## Overview

Webhooks allow you to receive real-time notifications when specific events occur in your Bud Runtime deployment. This is especially useful for long-running operations like model training, batch processing, or deployment status changes.

## Create Webhook

Register a new webhook endpoint.

```http
POST /v1/webhooks
```

### Request Body

```json
{
  "url": "https://your-server.com/webhook",
  "events": [
    "deployment.created",
    "deployment.ready",
    "deployment.failed",
    "batch.completed",
    "fine_tuning.completed"
  ],
  "secret": "your-webhook-secret",
  "description": "Production webhook for deployment events"
}
```

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `url` | string | Yes | HTTPS endpoint to receive webhook |
| `events` | array | Yes | List of events to subscribe to |
| `secret` | string | No | Secret for HMAC signature validation |
| `description` | string | No | Description of webhook purpose |

### Response

```json
{
  "id": "webhook_12345",
  "object": "webhook",
  "url": "https://your-server.com/webhook",
  "events": [
    "deployment.created",
    "deployment.ready",
    "deployment.failed",
    "batch.completed",
    "fine_tuning.completed"
  ],
  "created": 1234567890,
  "status": "active"
}
```

## Update Webhook

Modify an existing webhook configuration.

```http
PUT /v1/webhooks/{webhook_id}
```

### Request Body

```json
{
  "events": [
    "deployment.created",
    "deployment.ready",
    "model.trained"
  ],
  "status": "active"
}
```

### Response

```json
{
  "id": "webhook_12345",
  "object": "webhook",
  "url": "https://your-server.com/webhook",
  "events": [
    "deployment.created",
    "deployment.ready",
    "model.trained"
  ],
  "updated": 1234567890,
  "status": "active"
}
```

## List Webhooks

Get all configured webhooks.

```http
GET /v1/webhooks
```

### Response

```json
{
  "object": "list",
  "data": [
    {
      "id": "webhook_12345",
      "object": "webhook",
      "url": "https://your-server.com/webhook",
      "events": ["deployment.created", "deployment.ready"],
      "created": 1234567890,
      "status": "active",
      "last_triggered": 1234567890,
      "failure_count": 0
    }
  ]
}
```

## Test Webhook

Send a test event to verify webhook configuration.

```http
POST /v1/webhooks/{webhook_id}/test
```

### Request Body

```json
{
  "event": "deployment.ready"
}
```

### Response

```json
{
  "success": true,
  "status_code": 200,
  "response_time_ms": 145,
  "response_body": "OK"
}
```

## Webhook Events

### Deployment Events

#### deployment.created

Triggered when a new deployment is created.

```json
{
  "id": "evt_12345",
  "type": "deployment.created",
  "created": 1234567890,
  "data": {
    "deployment_id": "dep_12345",
    "model": "custom-llama-7b",
    "status": "creating",
    "replicas": 3
  }
}
```

#### deployment.ready

Triggered when a deployment is ready to serve requests.

```json
{
  "id": "evt_12346",
  "type": "deployment.ready",
  "created": 1234567890,
  "data": {
    "deployment_id": "dep_12345",
    "model": "custom-llama-7b",
    "endpoint": "https://dep-12345.api.your-domain.com",
    "ready_replicas": 3
  }
}
```

#### deployment.failed

Triggered when a deployment fails.

```json
{
  "id": "evt_12347",
  "type": "deployment.failed",
  "created": 1234567890,
  "data": {
    "deployment_id": "dep_12345",
    "model": "custom-llama-7b",
    "error": "Insufficient GPU resources",
    "failed_at": 1234567890
  }
}
```

### Fine-tuning Events

#### fine_tuning.started

```json
{
  "id": "evt_12348",
  "type": "fine_tuning.started",
  "created": 1234567890,
  "data": {
    "job_id": "ftjob-12345",
    "base_model": "llama2-7b",
    "training_file": "file-12345",
    "estimated_completion": 1234567890
  }
}
```

#### fine_tuning.completed

```json
{
  "id": "evt_12349",
  "type": "fine_tuning.completed",
  "created": 1234567890,
  "data": {
    "job_id": "ftjob-12345",
    "fine_tuned_model": "ft:llama2-7b:custom-12345",
    "training_metrics": {
      "loss": 0.234,
      "accuracy": 0.956
    }
  }
}
```

### Batch Events

#### batch.completed

```json
{
  "id": "evt_12350",
  "type": "batch.completed",
  "created": 1234567890,
  "data": {
    "batch_id": "batch_12345",
    "output_file_id": "file-67890",
    "request_counts": {
      "total": 1000,
      "completed": 980,
      "failed": 20
    },
    "duration_seconds": 3600
  }
}
```

### Model Events

#### model.loaded

```json
{
  "id": "evt_12351",
  "type": "model.loaded",
  "created": 1234567890,
  "data": {
    "model_id": "llama2-70b",
    "deployment_id": "dep_12345",
    "load_time_seconds": 45,
    "gpu_memory_used_gb": 65
  }
}
```

## Webhook Security

### Signature Verification

All webhook requests include a signature header for verification:

```python
import hmac
import hashlib

def verify_webhook_signature(payload, signature, secret):
    """Verify webhook signature using HMAC-SHA256."""
    expected_signature = hmac.new(
        secret.encode('utf-8'),
        payload.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    
    return hmac.compare_digest(expected_signature, signature)

# In your webhook handler
@app.route('/webhook', methods=['POST'])
def handle_webhook():
    signature = request.headers.get('X-Bud-Signature')
    payload = request.get_data(as_text=True)
    
    if not verify_webhook_signature(payload, signature, WEBHOOK_SECRET):
        return "Invalid signature", 401
    
    # Process webhook
    event = json.loads(payload)
    process_event(event)
    
    return "OK", 200
```

### Headers

Webhook requests include these headers:

```http
X-Bud-Signature: sha256=abc123...
X-Bud-Event: deployment.ready
X-Bud-Webhook-ID: webhook_12345
X-Bud-Delivery-ID: del_67890
Content-Type: application/json
```

## Retry Policy

Failed webhook deliveries are retried with exponential backoff:

```yaml
Retry Schedule:
  - Attempt 1: Immediate
  - Attempt 2: 10 seconds
  - Attempt 3: 60 seconds
  - Attempt 4: 10 minutes
  - Attempt 5: 1 hour
  - Attempt 6: 6 hours
  
Max Attempts: 6
Timeout: 30 seconds per request
```

## Webhook Response

Your webhook endpoint should return:

- **2xx status code**: Event processed successfully
- **3xx status code**: Webhook will follow redirects
- **4xx status code**: Client error, no retry
- **5xx status code**: Server error, will retry

Example response:

```json
{
  "status": "processed",
  "message": "Event handled successfully"
}
```

## Error Handling

### Failed Webhook

If a webhook fails repeatedly:

```json
{
  "id": "evt_12352",
  "type": "webhook.failed",
  "created": 1234567890,
  "data": {
    "webhook_id": "webhook_12345",
    "event_type": "deployment.ready",
    "attempts": 6,
    "last_error": "Connection timeout",
    "disabled": false
  }
}
```

### Disabled Webhook

Webhooks are automatically disabled after 100 consecutive failures:

```json
{
  "id": "evt_12353",
  "type": "webhook.disabled",
  "created": 1234567890,
  "data": {
    "webhook_id": "webhook_12345",
    "reason": "100 consecutive failures",
    "last_error": "Connection refused"
  }
}
```

## Best Practices

1. **Idempotency**: Handle duplicate events gracefully
2. **Async Processing**: Process webhooks asynchronously
3. **Timeout Handling**: Respond quickly (< 5 seconds)
4. **Error Logging**: Log all webhook errors
5. **Monitoring**: Set up alerts for webhook failures

## Example Implementation

### Node.js Express Handler

```javascript
const express = require('express');
const crypto = require('crypto');

app.post('/webhook', express.raw({ type: 'application/json' }), (req, res) => {
  const signature = req.headers['x-bud-signature'];
  const event = req.headers['x-bud-event'];
  
  // Verify signature
  const hash = crypto
    .createHmac('sha256', process.env.WEBHOOK_SECRET)
    .update(req.body)
    .digest('hex');
  
  if (`sha256=${hash}` !== signature) {
    return res.status(401).send('Invalid signature');
  }
  
  // Parse event
  const payload = JSON.parse(req.body);
  
  // Process event asynchronously
  setImmediate(() => {
    processWebhookEvent(event, payload);
  });
  
  // Respond immediately
  res.status(200).send('OK');
});

async function processWebhookEvent(eventType, payload) {
  switch (eventType) {
    case 'deployment.ready':
      await handleDeploymentReady(payload.data);
      break;
    case 'batch.completed':
      await handleBatchCompleted(payload.data);
      break;
    // ... handle other events
  }
}
```

### Python Flask Handler

```python
from flask import Flask, request, abort
import hmac
import hashlib
import json
from threading import Thread

app = Flask(__name__)

@app.route('/webhook', methods=['POST'])
def webhook():
    # Get signature
    signature = request.headers.get('X-Bud-Signature', '')
    
    # Verify signature
    expected = 'sha256=' + hmac.new(
        WEBHOOK_SECRET.encode(),
        request.data,
        hashlib.sha256
    ).hexdigest()
    
    if not hmac.compare_digest(signature, expected):
        abort(401)
    
    # Parse event
    event_type = request.headers.get('X-Bud-Event')
    payload = request.get_json()
    
    # Process async
    thread = Thread(
        target=process_webhook,
        args=(event_type, payload)
    )
    thread.start()
    
    return 'OK', 200

def process_webhook(event_type, payload):
    """Process webhook in background."""
    if event_type == 'deployment.ready':
        handle_deployment_ready(payload['data'])
    elif event_type == 'batch.completed':
        handle_batch_completed(payload['data'])
    # ... handle other events
```

For more API details, return to [API Reference](/api-reference/introduction).