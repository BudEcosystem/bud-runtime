# 2026-02-24 Learnings

## [14:30] budnotify CloudEventBase uses extra="forbid" [PROMOTED]

**Category**: architecture
**Service**: budnotify, budpipeline
**Tags**: notifications, pydantic, schema, 422, payload

> Any unknown top-level fields in the notification payload (like `execution_id`, `pipeline_event_type`) cause 422 Unprocessable Entity from budnotify. The publisher payload must only contain declared fields: `notification_type`, `name`, `subscriber_ids`, `actor`, `topic_keys`, `payload`, plus Dapr envelope fields. Put any extra data inside the nested `payload` dict.

**Context**: Adding `execution_id` and `pipeline_event_type` at the top level of `_build_event_payload` in publisher.py broke ALL Novu notifications (guardrails + usecases). Fix was Option A: move `execution_id` inside the `payload` dict and remove `pipeline_event_type` entirely.

---

## [14:31] budpipeline EventPublisher sends ONE payload to ALL topics [PROMOTED]

**Category**: architecture
**Service**: budpipeline
**Tags**: dapr, pubsub, notifications, event-publisher, dual-publish

> The same payload dict from `_build_event_payload` goes to callback topics (e.g. `budusecasesEvents`, `budAppMessages`) AND `notificationMessages` (Novu). You cannot add fields that one consumer needs but another rejects. Put service-specific data inside the nested `payload` dict, not at the top level.

---

## [14:32] budpipeline subscriber_ids auto-set enables Novu for ALL flows [PROMOTED]

**Category**: architecture
**Service**: budpipeline, budapp
**Tags**: notifications, novu, subscriber-ids, dual-publish

> `BudPipelineService.run_ephemeral_execution()` (budpipeline_service.py line 469) and `execute_pipeline()` (line 351) auto-set `subscriber_ids=user_id` when `user_id` is provided. This means ALL pipeline executions with a user_id will dual-publish to Novu via `notificationMessages` topic. Changes to the publisher payload format affect guardrails, usecases, and any future flow using pipelines.

**Context**: Committed in `fbb6fd786` (Feb 12). Before this commit, budnotify never received pipeline events.

---

## [14:33] budapp notification workflow_id vs budusecases workflow_id are different

**Category**: architecture
**Service**: budapp, budusecases, budadmin
**Tags**: workflow, notifications, CommonStatus, usecase-deployment

> `start_deployment` route creates a budapp workflow (`db_workflow.id`) for CommonStatus real-time tracking. budusecases also has its own `workflow_id` on the deployment object (returned by GET deployment). These are DIFFERENT IDs. The frontend store must use `startResult.workflow_id` (from the POST start response, which is the budapp workflow ID), not `deployment.workflow_id` (from GET deployment, which is budusecases' internal ID). The store does this correctly at `useUseCases.ts` lines 372-374.

---

## [14:34] CommonStatus data format and Novu event matching

**Category**: pattern
**Service**: budadmin, budapp
**Tags**: CommonStatus, workflow, notifications, novu, frontend

> CommonStatus reads `data.workflow_steps[events_field_id].steps` from the `/workflows/{id}` API. Each step needs `{id, title, description, payload}` where `payload.content.status` is "STARTED"/"COMPLETED"/"FAILED". Novu WebSocket events match steps by `payload.event === step.id`. The `workflow_id` in Novu events must match the `workflowId` prop passed to CommonStatus (filtered at line 125). Completion triggers when `event == "results"` with `content.status === "COMPLETED"`.

---

## [14:35] Analyze before coding — user preference

**Category**: preference
**Service**: general
**Tags**: workflow, debugging, analysis

> When debugging issues, present analysis with root cause identification and fix options BEFORE writing any code. User explicitly said "give me analysis first, don't code" and "No, there shouldn't be any change to notify" (meaning don't modify budnotify). Always trace the full call chain and present findings before proposing changes.

---

## [14:36] budapp auth login endpoint path and response format

**Category**: convention
**Service**: budapp
**Tags**: auth, login, api, token

> The budapp login endpoint is `/auth/login` (not `/api/v1/auth/login`). The response nests the token inside a `token` object: `response.token.access_token`. Also note the password `Budadmin@stud!0` contains `!` which causes shell escaping issues — use heredoc (`cat <<'EOF'`) or write JSON to a file first, then `curl -d @file.json`.

---

## [14:37] Kubernetes service and deployment names in ditto namespace

**Category**: convention
**Service**: general
**Tags**: kubernetes, port-forward, service-names, ditto

> In the `pde-ditto` namespace, service names are prefixed with `ditto-`: `ditto-budapp` (port 9082), `ditto-budpipeline`, `ditto-budusecases`. Deployment names match the service names. Port-forward commands need these correct names: `kubectl port-forward svc/ditto-budapp 9082:9082 -n pde-ditto`. Using just `budapp` returns "service not found". Port-forwards also drop frequently — always check with `curl` before assuming they're alive.

---
